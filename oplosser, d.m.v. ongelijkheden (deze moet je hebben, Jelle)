#input
hoogte = 4
breedte = 4
hints = [[0,[4,1]],[0,[2,4]],[2,[3,1]]]
zwarte_velden = [[1,2],[4,3]] 

#lege lijsten die we later nodig hebben
vakjes = []
ong = []
antwoord = []

#hieronder worden de hintvelden toegevoegd aan de zwarte velden.
for i in range(len(hints)):
    zwarte_velden.append(hints[i][1])

#hieronder wordt een bord gemaakt met alle vakjes.
for i in range(1,breedte+1):
    temp = []
    for j in range(1,hoogte+1):
        temp.append([i,j])
    vakjes.append(temp)

#hieronder wordt gezorgd dat de zwarte velden uit het bord gehaald worden, 
#zodat je alleen de witte vakjes overhoudt, genaamd 'vakjes'.
for i in range(len(zwarte_velden)):
    for j in range(breedte):
        if zwarte_velden[i] in vakjes[j]:
            vakjes[j].pop(vakjes[j].index(zwarte_velden[i]))
   
#deze functie vindt de witte kolom waar elk wit vakje in zit .        
def Kolommen(x,y):
    kolom = [[x,y]]
    nog_niet_klaar = True
    i=1
    while nog_niet_klaar and y-i >0:
        if [x,y-i] in zwarte_velden:
            nog_niet_klaar = False
        else:
            kolom += [[x,y-i]]
            i += 1
    nog_niet_klaar = True
    i=1
    while nog_niet_klaar and y+i<= hoogte:
        if [x,y+i] in zwarte_velden:
            nog_niet_klaar = False
        else:
            kolom += [[x,y+i]]
            i += 1
    kolom.sort()
    return kolom

#deze functie vindt de witte rij waar elk wit vakje in zit.
def Rijen(x,y):
    rij = [[x,y]]    
    nog_niet_klaar = True
    i=1
    while nog_niet_klaar and x-i>0:
        if [x-i,y] in zwarte_velden:
            nog_niet_klaar = False
        else:
            rij += [[x-i,y]]
            i += 1
    nog_niet_klaar = True
    i=1
    while nog_niet_klaar and x+i <= breedte:
        if [x+i,y] in zwarte_velden:
            nog_niet_klaar = False
        else:
            rij += [[x+i,y]]
            i += 1    
    rij.sort()
    return rij

#deze functie combineert de rijen en kolommen zodat voor elk vakje een 'omgeving' ontstaat, 
#oftewel, alle witte vakjes die dat vakje kan zien. Daarin moet minimaal 1 lampje, 
#dus dat is een vergelijking met >= teken. We voegen meteen de coefficienten toe,
#dus hoe vaak elk vakje voorkomt in de omgeving. Dat is steeds 1, maar voor later is dit belangrijk.
#We vermenigvuldigen beide kanten met -1, zodat de >= overgaat in een <= teken. 
#Daarna voegt het de omgevingen als ongelijkheden toe aan het uiteindelijke stelsel ongelijkheden.        
def omgaanongtoevoegen(rij,kolom):
    omgpervakje = []
    for k in range(len(rij)):
        omgpervakje.append(rij[k])
    for k in range(len(kolom)):
        if kolom[k] not in omgpervakje:
            omgpervakje.append(kolom[k])
    omgpervakje.sort()
    for k in range(len(omgpervakje)):
        omgpervakje[k] = [omgpervakje[k],-1]
    omgpervakje.append(-1)
    if omgpervakje not in ong:    
        ong.append(omgpervakje)
        
#deze functie voegt de rijen en kolommen als ongelijkheden toe aan het uiteindelijke stelsel ongelijkheden, 
#waarbij aan de 'rechterkant' van elke kolom en rij (de laatste index) een 1 komt te staan, als in:
#de linkerkant kan maximaal 1 zijn, er kan namelijk maar 1 lampje in een rij of kolom. 
#De coefficienten van de vakjes in de rijen en kolommen worden ook toegevoegd. 
#Die zijn nu 1, maar dat komt later van pas.
def rijkolomaanongtoevoegen(a):
    b = []
    for i in range(len(a)):
        b.append([a[i],1])
    b.append(1)
    if b not in ong:
        ong.append(b)

#hieronder wordt voor elke rij en kolom de functie rijkolomaanongtoevoegen opgeroepen. 
#Alleen rijen en kolommen met lengte > 1 worden toegevoegd, van rijen of kolommen
#met lengte 1 is natuurlijk duidelijk dat die sowieso maar maximaal 1 lampje kunnen bevatten, 
#dat is niks nieuws. De functie omgaanongtoevoegen wordt ook aangeroepen.
for i in range(len(vakjes)):
    for j in range(len(vakjes[i])):
        rij = Rijen(vakjes[i][j][0], vakjes[i][j][1])
        kolom = Kolommen(vakjes[i][j][0], vakjes[i][j][1])
        omgaanongtoevoegen(rij,kolom)
        if len(rij)>1:
            rijkolomaanongtoevoegen(rij)
        if len(kolom)>1:
            rijkolomaanongtoevoegen(kolom)

#deze functie voegt een omringend wit vakje aan een hint toe aan de losse hintongelijkheden, 
#met als laatste index het getal van de hint, alsin, er kunnen maximaal zoveel lampjes in die vakjes zitten.
#Het geeft ook meteen de coefficienten, hoe vaak de vakjes in de ongelijkheid voorkomen.
def coeffhintmaker(omringer):
    for j in range(len(vakjes)):
        if omringer in vakjes[j]:
            lossemaxhint.append([omringer,1]) 
            lossenegmaxhint.append([omringer,-1])                

#hieronder wordt voor elke hint gezocht welke witte vakjes grenzen aan de hint, 
#dan voegt de vorige functie die toe aan een losse ongelijkheid. Er zijn twee ongelijkheden voor elke hint,
#1 die zegt dat de grenzende vakjes minimaal het hintgetal aan lampjes kunnen bevatten,
#en 1 die zegt dat de grenzende vakjes maximaal het hintgetal aan lampjes kunnen bevatten. 
#Die laatste wordt met -1 vermenigvuldigt zodat ook die overgaat in een <= teken. 
#Als laatste worden alle losse hintongelijkheden toegevoegd aan de uiteindelijke lijst ongelijkheden. 
for i in range(len(hints)):
    lossemaxhint = []
    lossenegmaxhint = []
    
    hintboven = []
    hintboven.append(hints[i][1][0])
    hintboven.append(hints[i][1][1] +1)
    coeffhintmaker(hintboven)
    
    hintonder = []
    hintonder.append(hints[i][1][0]) 
    hintonder.append(hints[i][1][1] -1)
    coeffhintmaker(hintonder)
    
    hintlinks = []
    hintlinks.append(hints[i][1][0] -1)
    hintlinks.append(hints[i][1][1])
    coeffhintmaker(hintlinks)
    
    hintrechts = []
    hintrechts.append(hints[i][1][0] +1)
    hintrechts.append(hints[i][1][1])
    coeffhintmaker(hintrechts)
    
    lossemaxhint.sort()
    lossenegmaxhint.sort()
    
    lossemaxhint.append(hints[i][0])
    lossenegmaxhint.append(-1*hints[i][0])
    
    ong.append(lossemaxhint)
    ong.append(lossenegmaxhint) 
      
#Een oplettend lezer zou hebben gemerkt dat ong, de uiteindelijke lijst 
#ongelijkheden die moet worden opgelost, alleen ongelijkheden in de vorm ...<=... bevat. 
#En dat de variabelen, de vakjes, alleen de waarden 0 en 1 kunnen aannemen: 0 als ze geen lampje bevatten,
#1 als ze wel een lampje bevatten.

#de onderstaande functie telt 2 ongelijkheden bij elkaar op en stopt die in de lijst met ongelijkheden.
def optellen(a,b):
    optelling = []
    for i in range(len(a)-1):
        optelling.append([a[i][0], a[i][1]])
    for i in range(len(b)-1):
        zitalinA = False
        x = len(optelling)
        for j in range(len(optelling)):
            j = x - j - 1
            if b[i][0] == optelling[j][0]:
                optelling[j][1] = optelling[j][1]+b[i][1]
                if optelling[j][1] == 0:
                    optelling.pop(j)
                zitalinA = True
        if zitalinA == False:
            optelling.append([b[i][0],b[i][1]])   
    optelling.sort()
    optelling.append(a[-1]+b[-1])
    ong.append(optelling)

#deze functie maakt een lijst met alle witte vakjes.
vakjesrij = []
for i in range(len(vakjes)):
    for j in range(len(vakjes[i])):
        vakjesrij.append(vakjes[i][j])

#deze functie haalt uit elke vergelijking en uit de lijst met vakjes een vakje weg als 
#blijkt dat op dat vakje geen lampje kan staan. 
def kruisjeseruit(a):
    vakjesrij.remove(a)
    for i in range(len(ong)):
        for j in range(len(ong[i])-2,-1,-1):
            if a == ong[i][j][0]:
                ong[i].pop(j)
              
#deze functie haalt uit elke vergelijking en uit de lijst met vakjes een vakje weg als 
#blijkt dat op dat vakje een lampje staat, en voegt dat vakje toe aan het uiteindelijke antwoord. 
#Ook vermindert de functie de rechterkant van de ongelijkheid met de coefficient 
#van de variabele/het vakje waar het lampje stond.           
def lampjeseruit(a):
    vakjesrij.remove(a)
    antwoord.append(a)
    for i in range(len(ong)):
        for j in range(len(ong[i])-2,-1,-1):
            if a == ong[i][j][0]:
                ong[i][-1] = ong[i][-1] - ong[i][j][1]
                ong[i].pop(j)

#een boolean die aangeeft als de functie moet stoppen omdat de puzzel niet uniek oplosbaar is. 
stop = False

#de while loop-voorwaarde betekent: zolang er nog vakjes geen waarde 0 of 1 toegekend hebben gekregen.
while vakjesrij != []:
    
    #maak een kopie van de nog witte vakjes
    vakjessave = []
    for i in range(len(vakjesrij)):
        vakjessave.append(vakjesrij[i])
    
    #voor elke ongelijkheid
    for i in range(len(ong)-1, -1, -1): 
        #als alleen de rechterkant over is, haal de ongelijkheid uit de lijst.
        if len(ong[i]) == 1:
            ong.pop(i)
        #anders, kijk voor elk vakje in de ongelijkheid of je een 0 respectievelijk 1
        #kan forceren, en roep dan kruisjeseruit respectievelijk lampjeseruit aan om die vakjes
        #uit alle ongelijkheden te halen. 
        else:
            for j in range(len(ong[i])-2, -1, -1):
                linkerkant = ong[i][-1]
                for k in [x for x in range(len(ong[i])-2,-1,-1) if x != j]:
                    if ong[i][k][1] < 0:
                        linkerkant = linkerkant - ong[i][k][1]
                if ong[i][j][1] < 0 and linkerkant <= ong[i][j][1]:
                    lampjeseruit(ong[i][j][0])
                elif ong[i][j][1] > 0 and linkerkant < ong[i][j][1]:
                    kruisjeseruit(ong[i][j][0])
    
    #voor elke ongelijkheid, als alleen de rechterkant over is, haal de ongelijheid uit de lijst.
    for i in range(len(ong)-1,-1,-1):
        if len(ong[i]) == 1:
            ong.pop(i)
  
    #als er dubbele ongelijkheden in de lijst zitten, zorg dat de duplicaten eruit worden gehaald
    for i in range(len(ong)-1,-1,-1):
        for j in range(i):
            if ong[i] == ong[j]:
                ong.pop(i)
                break
    
    #hieronder wordt voor elke ongelijkheid gekeken of er überhaupt nog nuttige informatie in zit, 
    #anders wordt de ongelijkheid eruit gehaald, bijvoorbeeld als je voor elk vakje met positieve coefficient een lampje in zou
    #kunnen vullen en je nog niet aan de positieve waarde aan de rechterkant van de ongelijkheid komt. 
    #Hetzelfde geldt voor voor elk vakje met negatieve coefficient een lampje invullen en nog niet onder de negatieve waarde aan
    #de rechterkant van de vergelijking komen.
    for i in range(len(ong)-1,-1,-1):
        maximum = 0
        minimum = 0
        for j in range(len(ong[i])-1):
            if ong[i][j][1] > 0:
                maximum = maximum + ong[i][j][1]
            else:
                minimum = minimum + ong[i][j][1]
        if maximum <= ong[i][-1] or minimum >= ong[i][-1]:
            ong.pop(i)
    
    #vergelijk de nog witte vakjes met de kopie van de oude nog witte vakjes, 
    #als er niks veranderd is heeft de loop nieuwe informatie nodig en worden er 
    #rijen bij elkaar opgeteld zodat daar weer informatie uit kan worden gehaald. 
    #Als er bij deze stap nog maar 1 vergelijking over is betekent dat dat de puzzel niet uniek oplosbaar is. 
    if vakjessave == vakjesrij:
        if len(ong) == 1:
            stop = True
        else:
            for i in range(len(ong)):
                for j in range(i+1,len(ong)):
                    optellen(ong[i],ong[j])
    
    #stop als de functie niet uniek oplosbaar is.
    if stop == True:
        print('Error, is niet uniek oplosbaar')
        break
    
print(antwoord)
