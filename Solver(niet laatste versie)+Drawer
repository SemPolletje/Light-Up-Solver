#input
hoogte = 25
breedte = 25
hints = [[2,[1,5]], [1,[1,11]], [2,[1,15]], [0,[1,17]], [0,[1,18]], [1,[1,20]], [0,[2,2]], [1,[2,8]], [0,[2,22]], [2,[3,20]], [2,[4,2]], [0,[4,17]], [3,[4,21]], [0,[5,4]], [1,[5,13]], [2,[5,25]], [2,[6,9]], [1,[6,11]], [1,[6,18]], [1,[8,1]], [3,[8,14]], [0,[8,24]], [1,[9,20]], [1,[9,24]], [1,[10,9]], [0,[10,24]], [1,[11,5]], [0,[12,8]], [0,[12,16]], [1,[12,18]], [2,[12,22]], [1,[12,24]], [2,[13,3]], [1,[13,12]], [2,[13,21]], [1,[14,2]], [2,[14,4]], [0,[16,4]], [2,[16,5]], [3,[16,9]], [0,[16,13]], [2,[16,20]], [1,[16,21]], [2,[17,6]], [0,[17,11]], [2,[17,23]], [1,[18,14]], [1,[20,8]], [2,[20,10]], [0,[20,15]], [0,[20,17]], [2,[21,1]], [2,[21,11]], [2,[21,13]], [0,[21,22]], [2,[22,14]], [3,[22,24]], [1,[23,21]], [3,[24,2]], [3,[24,4]], [0,[24,16]], [1,[25,9]], [0,[25,21]], [0,[25,23]]]
zwarte_velden = [[1,3], [1,4], [1,8], [1,10], [1,13], [2,3], [2,9], [2,10], [2,12], [2,13], [2,14], [2,20], [2,24], [3,5], [3,13], [3,17], [3,24], [3,25], [4,10], [4,12], [4,25], [5,10], [5,15], [5,16], [5,23], [6,1], [6,2], [6,3], [6,16], [8,6], [8,12], [8,25], [9,1], [9,3], [9,4], [9,10], [9,15], [9,16], [10,5], [10,6], [10,12], [10,13], [10,14], [10,17], [10,21], [10,22], [10,25], [11,1], [11,9], [11,20], [11,25], [12,2], [12,10], [12,13], [13,1], [13,2], [13,5], [13,10], [13,14], [13,16], [13,23], [13,24], [13,25], [14,8], [14,10], [14,13], [14,16], [14,18], [14,24], [15,1], [15,6], [15,17], [15,21], [15,25], [16,1], [16,2], [16,12], [16,14], [16,17], [17,2], [17,10], [17,16], [17,22], [17,25], [18,1], [18,2], [18,12], [18,20], [18,25], [20,23], [20,24], [20,25], [21,3], [21,10], [21,16], [22,1], [22,5], [22,9], [22,16], [23,1], [23,2], [23,6], [23,9], [23,13], [24,6], [24,12], [24,13], [24,14], [24,17], [24,18], [24,23], [24,24], [25,6], [25,8], [25,11], [25,13], [25,15], [25,16], [25,18], [25,22]]

#lege lijsten die we later nodig hebben.
vakjesinclkruisjes = []
ong = []
antwoord = []
kruisjes = []

#hieronder worden de hintvelden toegevoegd aan de zwarte velden.
for i in range(len(hints)):
    zwarte_velden.append(hints[i][1])

#hieronder wordt een lijst gemaakt met alle vakjes.
for i in range(1,breedte+1):
    for j in range(1,hoogte+1):
        vakjesinclkruisjes.append([i,j])

#hieronder wordt gezorgd dat de zwarte velden uit de lijst met vakjes gehaald worden, 
#zodat je alleen de witte vakjes overhoudt, genaamd 'vakjesinclkruisjes'.
for i in range(len(zwarte_velden)):
    if zwarte_velden[i] in vakjesinclkruisjes:
        vakjesinclkruisjes.remove(zwarte_velden[i])
            
lege_vakjes = [] #we moeten ook bijhouden welke witte vakjes leeg zijn, dus ook geen kruisje bevatten.
for i in range(len(vakjesinclkruisjes)):
    lege_vakjes.append(vakjesinclkruisjes[i])

def omhint(vakje): # deze functie geeft de lege vakjes om een hint.
    omheen = []
    lijn = [0,0]
    if [vakje[0],vakje[1]+1] in lege_vakjes: #dit voegt het vakje erboven toe als die leeg is.
        omheen += [[vakje[0],vakje[1]+1]]
        lijn[1] += 1
    if [vakje[0],vakje[1]-1] in lege_vakjes: #dit voegt het vakje eronder toe als die leeg is.
        omheen += [[vakje[0],vakje[1]-1]]
        lijn[1] -= 1
    if [vakje[0]+1,vakje[1]] in lege_vakjes: #dit voegt het vakje rechts toe als die leeg is.
        omheen += [[vakje[0]+1,vakje[1]]]
        lijn[0] += 1
    if [vakje[0]-1,vakje[1]] in lege_vakjes: #dit voegt het vakje links toe als die leeg  is.
        omheen += [[vakje[0]-1,vakje[1]]]
        lijn[0] -= 1
    isnietlijn = True
    if lijn == [0,0]:  #dit is voor het geval dat bij een 1 hint de twee vrije vakjes tegenover elkaar staan, want dan kan je geen kruisjes zetten.
        isnietlijn = False
    return [omheen,isnietlijn]

nognuttig = True
while nognuttig: #hiermee vullen we al een aantal kruisjes en lampjes in, zodat we later minder ongelijkheden hebben.
    nognuttig = False
    verwijderen = [False]*len(hints)
    #we willen ook weten op welke vakjes de hints staan.
    hintloc = []
    for i in range(len(hints)):
        hintloc.append(hints[i][1])
    for i in range(len(hints)):
        hintvakje = hints[i][1]
        omvakjes = []
        
        for j in range(len(omhint(hintvakje)[0])):
            omvakjes.append(omhint(hintvakje)[0][j])
        if hints[i][0] == 0: #bij een 0 hint kunnen we er kruisjes omheenzetten.
            for j in range(len(omvakjes)):
                if omvakjes[j] in kruisjes:
                    pass
                else:
                    kruisjes.append(omvakjes[j])
                    lege_vakjes.remove(omvakjes[j])
            verwijderen[i]=True
            nognuttig = True
        elif len(omvakjes) == hints[i][0]: #als het aantal vrije vakjes gelijk is aan de hint kunnen we op die vakjes lampjes zetten.
            for j in range(len(omvakjes)):
                antwoord.append(omvakjes[j])
                vakjesinclkruisjes.remove(omvakjes[j])
                lege_vakjes.remove(omvakjes[j]) 
                if [omvakjes[j][0]-1,omvakjes[j][1]] in hintloc and [omvakjes[j][0]-1,omvakjes[j][1]] != hints[i][1]:
                    hints[hintloc.index([omvakjes[j][0]-1,omvakjes[j][1]])][0] = hints[hintloc.index([omvakjes[j][0]-1,omvakjes[j][1]])][0] - 1
                if [omvakjes[j][0],omvakjes[j][1]-1] in hintloc and [omvakjes[j][0],omvakjes[j][1]-1] != hints[i][1]:
                    hints[hintloc.index([omvakjes[j][0],omvakjes[j][1]-1])][0] = hints[hintloc.index([omvakjes[j][0],omvakjes[j][1]-1])][0] - 1
                if [omvakjes[j][0]+1,omvakjes[j][1]] in hintloc and [omvakjes[j][0]+1,omvakjes[j][1]] != hints[i][1]:
                    hints[hintloc.index([omvakjes[j][0]+1,omvakjes[j][1]])][0] = hints[hintloc.index([omvakjes[j][0]+1,omvakjes[j][1]])][0] - 1
                if [omvakjes[j][0],omvakjes[j][1]+1] in hintloc and [omvakjes[j][0],omvakjes[j][1]+1] != hints[i][1]:
                    hints[hintloc.index([omvakjes[j][0],omvakjes[j][1]+1])][0] = hints[hintloc.index([omvakjes[j][0],omvakjes[j][1]+1])][0] - 1
                
                #nu kunnen we kruisjes zetten in de rij en kolom van de hint.
                x = omvakjes[j][0]
                y = omvakjes[j][1]
                j=1
                nog_niet_klaar = True
                while nog_niet_klaar and x+j <= breedte: #zoekt voor vakjes rechts van het lampje.
                    if [x+j,y] in zwarte_velden:
                        nog_niet_klaar = False
                    else:
                        if [x+j,y] in lege_vakjes:
                            lege_vakjes.remove([x+j,y])
                        j += 1
                j = 1
                nog_niet_klaar = True
                while nog_niet_klaar and x-j > 0: #zoekt voor vakjes links van het lampje.
                    if [x-j,y] in zwarte_velden:
                        nog_niet_klaar = False
                    else:
                        if [x-j,y] in lege_vakjes:
                            lege_vakjes.remove([x-j,y])
                        j += 1
                j = 1
                nog_niet_klaar = True
                while nog_niet_klaar and y+j <= hoogte: #zoekt voor vakjes boven het lampje.
                    if [x,y+j] in zwarte_velden:
                        nog_niet_klaar = False
                    else:
                        if [x,y+j] in lege_vakjes:
                            lege_vakjes.remove([x,y+j])
                        j += 1
                j = 1
                nog_niet_klaar = True
                while nog_niet_klaar and y-j > 0: #zoekt voor vakjes onder het lampje.
                    if [x,y-j] in zwarte_velden:
                        nog_niet_klaar = False
                    else:
                        if [x,y-j] in lege_vakjes:
                            lege_vakjes.remove([x,y-j])
                        j += 1
                        
            verwijderen[i] = True
            nognuttig = True
            
        elif len(omvakjes) == hints[i][0]+1: #in dit geval kunnen we kruisjes zetten op vakjes die een hoekpunt gemeen hebben met de hint.
            
            if hints[i][0] == 3:
                if [hintvakje[0]-1,hintvakje[1]-1] in lege_vakjes:
                    kruisjes.append([hintvakje[0]-1,hintvakje[1]-1])
                    lege_vakjes.remove([hintvakje[0]-1,hintvakje[1]-1])
                    nognuttig = True
                if [hintvakje[0]-1,hintvakje[1]+1] in lege_vakjes:
                    kruisjes.append([hintvakje[0]-1,hintvakje[1]+1])
                    lege_vakjes.remove([hintvakje[0]-1,hintvakje[1]+1])
                    nognuttig = True
                if [hintvakje[0]+1,hintvakje[1]-1] in lege_vakjes:
                    kruisjes.append([hintvakje[0]+1,hintvakje[1]-1])
                    lege_vakjes.remove([hintvakje[0]+1,hintvakje[1]-1])
                    nognuttig = True
                if [hintvakje[0]+1,hintvakje[1]+1] in lege_vakjes:
                    kruisjes.append([hintvakje[0]+1,hintvakje[1]+1])
                    lege_vakjes.remove([hintvakje[0]+1,hintvakje[1]+1])
                    nognuttig = True
            if hints[i][0] == 2:
                if [hintvakje[0]-1,hintvakje[1]-1] in lege_vakjes and [hintvakje[0]-1,hintvakje[1]] in lege_vakjes and [hintvakje[0],hintvakje[1]-1] in lege_vakjes:
                    kruisjes.append([hintvakje[0]-1,hintvakje[1]-1])
                    lege_vakjes.remove([hintvakje[0]-1,hintvakje[1]-1])
                    nognuttig = True
                if [hintvakje[0]-1,hintvakje[1]+1] in lege_vakjes and [hintvakje[0]-1,hintvakje[1]] in lege_vakjes and [hintvakje[0],hintvakje[1]+1] in lege_vakjes:
                    kruisjes.append([hintvakje[0]-1,hintvakje[1]+1])
                    lege_vakjes.remove([hintvakje[0]-1,hintvakje[1]+1])
                    nognuttig = True
                if [hintvakje[0]+1,hintvakje[1]-1] in lege_vakjes and [hintvakje[0]+1,hintvakje[1]] in lege_vakjes and [hintvakje[0],hintvakje[1]-1] in lege_vakjes:
                    kruisjes.append([hintvakje[0]+1,hintvakje[1]-1])
                    lege_vakjes.remove([hintvakje[0]+1,hintvakje[1]-1])
                    nognuttig = True
                if [hintvakje[0]+1,hintvakje[1]+1] in lege_vakjes and [hintvakje[0]+1,hintvakje[1]] in lege_vakjes and [hintvakje[0],hintvakje[1]+1] in lege_vakjes:
                    kruisjes.append([hintvakje[0]+1,hintvakje[1]+1])
                    lege_vakjes.remove([hintvakje[0]+1,hintvakje[1]+1]) 
                    nognuttig = True
            if hints[i][0] == 1 and omhint(hintvakje)[1]: 
                if [omhint(hintvakje)[0][1][0],omhint(hintvakje)[0][0][1]] in lege_vakjes:
                    lege_vakjes.remove([omhint(hintvakje)[0][1][0],omhint(hintvakje)[0][0][1]])
                    kruisjes.append([omhint(hintvakje)[0][1][0],omhint(hintvakje)[0][0][1]])
                    nognuttig = True
    
    k=len(hints)
    for i in range(0,k): #de volledig ingevulde hints fungeren slechts als een zwart veld, dus die halen we weg uit de lijst met hints.
        if verwijderen[k-i-1]:
            del hints[k-i-1] 
         
#deze functie vindt de witte kolom waar elk wit vakje in zit .        
def Kolommen(x,y):
    kolom = [[x,y]]
    nog_niet_klaar = True
    i=1
    while nog_niet_klaar and y-i >0:
        if [x,y-i] in zwarte_velden:
            nog_niet_klaar = False
        else:
            kolom += [[x,y-i]]
            i += 1
    nog_niet_klaar = True
    i=1
    while nog_niet_klaar and y+i<= hoogte:
        if [x,y+i] in zwarte_velden:
            nog_niet_klaar = False
        else:
            kolom += [[x,y+i]]
            i += 1
    kolom.sort()
    return kolom

#deze functie vindt de witte rij waar elk wit vakje in zit.
def Rijen(x,y):
    rij = [[x,y]]    
    nog_niet_klaar = True
    i=1
    while nog_niet_klaar and x-i>0:
        if [x-i,y] in zwarte_velden:
            nog_niet_klaar = False
        else:
            rij += [[x-i,y]]
            i += 1
    nog_niet_klaar = True
    i=1
    while nog_niet_klaar and x+i <= breedte:
        if [x+i,y] in zwarte_velden:
            nog_niet_klaar = False
        else:
            rij += [[x+i,y]]
            i += 1    
    rij.sort()
    return rij

#deze functie combineert de rijen en kolommen zodat voor elk vakje een 'omgeving' ontstaat, 
#oftewel, alle witte vakjes die dat vakje kan zien. Daarin moet minimaal 1 lampje, 
#dus dat is een vergelijking met >= teken. We voegen meteen de coefficienten toe,
#dus hoe vaak elk vakje voorkomt in de omgeving. Dat is steeds 1, maar voor later is dit belangrijk.
#We vermenigvuldigen beide kanten met -1, zodat de >= overgaat in een <= teken. 
#Daarna voegt het de omgevingen als ongelijkheden toe aan het uiteindelijke stelsel ongelijkheden.        
def omgaanongtoevoegen(rij,kolom):
    omgpervakje = []
    for k in range(len(rij)):
        omgpervakje.append(rij[k])
    for k in range(len(kolom)):
        if kolom[k] not in omgpervakje:
            omgpervakje.append(kolom[k])
    omgpervakje.sort()
    for k in range(len(omgpervakje)):
        omgpervakje[k] = [omgpervakje[k],-1]
    omgpervakje.append(-1)
    if omgpervakje not in ong:    
        ong.append(omgpervakje)
        
#deze functie voegt de rijen en kolommen als ongelijkheden toe aan het uiteindelijke stelsel ongelijkheden, 
#waarbij aan de 'rechterkant' van elke kolom en rij (de laatste index) een 1 komt te staan, als in:
#de linkerkant kan maximaal 1 zijn, er kan namelijk maar 1 lampje in een rij of kolom. \
#Deze ongelijkheden hebben dus ook de vorm ... <= ... .
#De coefficienten van de vakjes in de rijen en kolommen worden ook toegevoegd. 
#Die zijn nu 1, maar dat komt later van pas.
def rijkolomaanongtoevoegen(a):
    b = []
    for i in range(len(a)):
        b.append([a[i],1])
    b.append(1)
    if b not in ong:
        ong.append(b)

#hieronder wordt voor elke rij en kolom de functie rijkolomaanongtoevoegen opgeroepen. 
#Alleen de lege vakjes van rijen en kolommen met meer dan 1 leeg vakje worden toegevoegd, want van rijen of kolommen
#met 1 leeg vakje is natuurlijk duidelijk dat die sowieso maar maximaal 1 lampje kunnen bevatten, 
#dat is niks nieuws. De functie omgaanongtoevoegen wordt ook aangeroepen om de omgevingen van elk vakje, 
#of eigenlijkl alleen de lege vakjes in de omgevingen van elk vakje,
#in de lijst ongelijkheden te zetten. Er worden alleen omgevingen toegevoegd als er in die omgeving 
#nog geen lampje staat, want er moet minimaal 1 lampje in een omgeving,
#dus als er al een lampje staat heb je er niks aan. 
#Er worden ook alleen rijen of kolommen zonder lampje toegevoegd, want als er in een rij of een kolom
#al een lampje staat hebben die ongelijkheden ook weinig nut, er staat immers al een lampje in, 
#die ongelijkheden brengen geen extra informatie.
for i in range(len(vakjesinclkruisjes)):
    lampjekolom = 0
    lampjerij = 0
    
    rij = Rijen(vakjesinclkruisjes[i][0], vakjesinclkruisjes[i][1])
    for j in range(len(antwoord)):
        if antwoord[j] in rij:
            lampjerij = 1
            break
    for j in range(len(rij)-1,-1,-1):
        if rij[j] not in lege_vakjes:
            rij.pop(j)
    kolom = Kolommen(vakjesinclkruisjes[i][0], vakjesinclkruisjes[i][1])
    for j in range(len(antwoord)):
        if antwoord[j] in kolom:
            lampjekolom = 1
            break
    for j in range(len(kolom)-1,-1,-1):
        if kolom[j] not in lege_vakjes:
            kolom.pop(j)
       
    if lampjerij + lampjekolom == 0:
        omgaanongtoevoegen(rij,kolom)
    if len(rij)>1 and lampjerij == 0:
        rijkolomaanongtoevoegen(rij)
    if len(kolom)>1 and lampjekolom == 0:
        rijkolomaanongtoevoegen(kolom)

#hieronder wordt voor elke resterende hint gezocht welke lege vakjes grenzen aan de hint, 
#dan worden die vakjes toegevoegd aan 2 ongelijkheden, want er moeten twee ongelijkheden komen voor elke hint.
#1 die zegt dat de grenzende vakjes minimaal het hintgetal aan lampjes kunnen bevatten,
#en 1 die zegt dat de grenzende vakjes maximaal het hintgetal aan lampjes kunnen bevatten. 
#Die laatste wordt met -1 vermenigvuldigt zodat ook die overgaat in een <= teken. 
#Als laatste worden alle losse hintongelijkheden toegevoegd aan de uiteindelijke lijst ongelijkheden. 
for i in range(len(hints)):
    lossemaxhint = []
    lossenegmaxhint = []
    if [hints[i][1][0],hints[i][1][1]+1] in lege_vakjes: #dit voegt het vakje erboven toe als die leeg is
        lossemaxhint.append([[hints[i][1][0],hints[i][1][1]+1],1])
        lossenegmaxhint.append([[hints[i][1][0],hints[i][1][1]+1],-1])
    if [hints[i][1][0],hints[i][1][1]-1] in lege_vakjes: #dit voegt het vakje eronder toe als die leeg is
        lossemaxhint.append([[hints[i][1][0],hints[i][1][1]-1],1])
        lossenegmaxhint.append([[hints[i][1][0],hints[i][1][1]-1],-1])
    if [hints[i][1][0]+1,hints[i][1][1]] in lege_vakjes: #dit voegt het vakje rechts toe als die leeg is
        lossemaxhint.append([[hints[i][1][0]+1,hints[i][1][1]],1])
        lossenegmaxhint.append([[hints[i][1][0]+1,hints[i][1][1]],-1])
    if [hints[i][1][0]-1,hints[i][1][1]] in lege_vakjes: #dit voegt het vakje links toe als die leeg  is
        lossemaxhint.append([[hints[i][1][0]-1,hints[i][1][1]],1])
        lossenegmaxhint.append([[hints[i][1][0]-1,hints[i][1][1]],-1])
    lossemaxhint.sort()
    lossenegmaxhint.sort()
    lossemaxhint.append(hints[i][0])
    lossenegmaxhint.append(-1*hints[i][0])
    ong.append(lossemaxhint)
    ong.append(lossenegmaxhint) 
      
#Een oplettend lezer zou hebben opgemerkt dat ong, de uiteindelijke lijst 
#ongelijkheden die moet worden opgelost, alleen ongelijkheden in de vorm ...<=... bevat. 
#En dat de variabelen, de vakjes, alleen de waarden 0 en 1 kunnen aannemen: 0 als ze geen lampje bevatten,
#1 als ze wel een lampje bevatten.

#de onderstaande functie telt 2 ongelijkheden bij elkaar op en stopt die in de lijst met ongelijkheden.
def optellen(a,b):
    optelling = []
    for i in range(len(a)-1):
        optelling.append([a[i][0], a[i][1]])
    for i in range(len(b)-1):
        zitalinA = False
        for j in range(len(optelling)-1,-1,-1):
            if b[i][0] == optelling[j][0]:
                optelling[j][1] = optelling[j][1]+b[i][1]
                if optelling[j][1] == 0:
                    optelling.pop(j)
                zitalinA = True
                break
        if zitalinA == False:
            optelling.append([b[i][0],b[i][1]])   
    optelling.sort()
    optelling.append(a[-1]+b[-1])
    if optelling not in ong:
        ong.append(optelling)

#deze functie haalt uit elke vergelijking en uit de lijst met vakjes een vakje weg als 
#blijkt dat op dat vakje geen lampje kan staan. 
def kruisjeseruit(a):
    lege_vakjes.remove(a)
    for i in range(len(ong)):
        for j in range(len(ong[i])-2,-1,-1):
            if a == ong[i][j][0]:
                ong[i].pop(j)
              
#deze functie haalt uit elke vergelijking en uit de lijst met vakjes een vakje weg als 
#blijkt dat op dat vakje een lampje staat, en voegt dat vakje toe aan het uiteindelijke antwoord. 
#Ook vermindert de functie de rechterkant van de ongelijkheid met de coefficient 
#van de variabele/het vakje waar het lampje stond.           
def lampjeseruit(a):
    lege_vakjes.remove(a)
    antwoord.append(a)
    for i in range(len(ong)):
        for j in range(len(ong[i])-2,-1,-1):
            if a == ong[i][j][0]:
                ong[i][-1] = ong[i][-1] - ong[i][j][1]
                ong[i].pop(j)

#een boolean die aangeeft als de functie moet stoppen omdat de puzzel niet uniek oplosbaar is. 
stop = False

#de while loop-voorwaarde betekent: zolang er nog witte vakjes geen waarde 0 of 1 toegekend hebben gekregen.
while lege_vakjes != []:
    #hieronder wordt een kopie gemaakt van de nog lege vakes.
    vakjessave = []
    for i in range(len(lege_vakjes)):
        vakjessave.append(lege_vakjes[i])
    
    #hieronder staat een loop die voor elke ongelijkheid kijkt of er nullen of enen geforceerd kunnen worden.
    for i in range(len(ong)-1, -1, -1): 
        #als alleen de rechterkant over is, haal de ongelijkheid uit de lijst.
        if len(ong[i]) == 1:
            ong.pop(i)
        #anders, kijk voor elk vakje in de ongelijkheid of je een 0 respectievelijk 1
        #kan forceren, en roep dan kruisjeseruit respectievelijk lampjeseruit aan om die vakjes
        #uit alle ongelijkheden te halen. 
        else:
            for j in range(len(ong[i])-2, -1, -1):
                linkerkant = ong[i][-1]
                for k in [x for x in range(len(ong[i])-2,-1,-1) if x != j]:
                    if ong[i][k][1] < 0:
                        linkerkant = linkerkant - ong[i][k][1]
                if ong[i][j][1] < 0 and linkerkant <= ong[i][j][1]:
                    lampjeseruit(ong[i][j][0])
                elif ong[i][j][1] > 0 and linkerkant < ong[i][j][1]:
                    kruisjeseruit(ong[i][j][0])
    
    #de onderstaande code vergelijkt de nog lege vakjes met de kopie van de oude nog lege vakjes, 
    #als er niks veranderd is heeft de loop dus nieuwe informatie nodig en worden er 
    #rijen bij elkaar opgeteld zodat daar weer informatie uit kan worden gehaald. Er worden hier ook
    #onnodige ongelijkheden uit de lijst met ongelijkheden gehaald.
    #Als er bij deze stap nog maar 1 vergelijking over is betekent dat dat de puzzel niet uniek oplosbaar is. 
    if vakjessave == lege_vakjes:
        #hieronder staat: als er nog maar 1 ongelijkheid is, en zelfs daar kan niks mee gedaan worden,
        #dan is de puzzel niet uniek oplosbaar, en moet hij stoppen met oplossen.
        if len(ong) == 1:
            stop = True
        else:
            #voor elke ongelijkheid, als alleen de rechterkant over is, haal de ongelijkheid uit de lijst.
            for i in range(len(ong)-1,-1,-1):
                if len(ong[i]) == 1:
                    ong.pop(i)
          
            #als er dubbele ongelijkheden in de lijst zitten, zorg dat de duplicaten eruit worden gehaald.
            for i in range(len(ong)-1,-1,-1):
                for j in range(i):
                    if ong[i] == ong[j]:
                        ong.pop(i)
                        break
            
            #hieronder wordt voor elke ongelijkheid gekeken of er überhaupt nog nuttige informatie in zit, 
            #anders wordt de ongelijkheid eruit gehaald, namelijk als je voor elk vakje met positieve coefficient een lampje in zou
            #kunnen vullen en je nog niet aan de positieve maximumwaarde aan de rechterkant van de ongelijkheid komt. 
            for i in range(len(ong)-1,-1,-1):
                maximum = 0
                for j in range(len(ong[i])-1):
                    if ong[i][j][1] > 0:
                        maximum = maximum + ong[i][j][1]
                if maximum <= ong[i][-1]:
                    ong.pop(i)
            
            #onderstaande loop kijkt voor elke twee vergelijkingen of de ene minimaal dezelfde informatie bevat
            #als de andere, dan wordt die andere eruit gehaald, die is immers overbodig. Dit wordt verder uitgelegd
            #in het verslag.
            verwijderen = []
            for i in range(len(ong)-1,-1,-1):
                for j in range(i):   
                    if len(ong[j]) != len(ong[i]):
                        if len(ong[j]) > len(ong[i]):
                            a = ong[i]
                            b = ong[j]
                        if len(ong[j]) < len(ong[i]):
                            a = ong[j]
                            b = ong[i]
                        verschil = []
                        for k in range(len(b)-1):
                            verschil.append(b[k])
                        nuttig = True
                        for k in range(len(a)-1):
                            if a[k] not in verschil:
                                nuttig = False
                                break
                            else:
                                verschil.remove(a[k])
                        if nuttig == True:
                            bsterker = True
                            asterker = True
                            if b[-1] > a[-1]:
                                bsterker = False
                            else:
                                for k in range(len(verschil)):
                                    if verschil[k][1] < 0:
                                        bsterker = False
                                        break
                            if a[-1] > b[-1]:
                                asterker = False
                            else:
                                for k in range(len(verschil)):
                                    if verschil[k][1] > 0:
                                        asterker = False
                                        break
                            if asterker == True:
                                if b == ong[i]:
                                    ong.pop(i)
                                    break
                                else:
                                    if b not in verwijderen:
                                        verwijderen.append(b)
                            if bsterker == True:
                                if a == ong[i]:
                                    ong.pop(i)
                                    break
                                else:
                                    if a not in verwijderen:
                                        verwijderen.append(a)
            for i in range(len(verwijderen)):
                if verwijderen[i] in ong:
                    ong.remove(verwijderen[i])            
            
            #de onderstaande loop kijkt voor elke twee ongelijkheden of ze variabelen gemeen hebben, 
            #en in dat geval worden die twee dan bij elkaar opgeteld door de functie 'optellen' aan te roepen,
            #en worden de nieuwe opgetelde ongelijkheden aan de ongelijkhedenlijst toegevoegd.
            x = len(ong)
            for i in range(x):
                for j in range(i+1,x):
                    doen = False
                    for k in range(len(ong[i])-1):
                        for l in range(len(ong[j])-1):
                            if ong[i][k][0] == ong[j][l][0]:
                                doen = True
                                break
                        if doen == True:
                            break
                    if doen == True:
                        optellen(ong[i],ong[j])
                
    #stop als de functie niet uniek oplosbaar is.
    if stop == True:
        print('Error, is niet uniek oplosbaar')
        break
antwoord.sort()   
print(antwoord)
# import turtle om het bord te kunnen tekenen
import turtle

#Verander de 'coördinaten' van de zwarte_velden en antwoorden, aangezien deze bij linksonder
#[1,1] beginnen, terwijl ze in turtle bij [0,0] linksonder beginnen.
for i in range(len(zwarte_velden)):
    zwarte_velden[i][0] = zwarte_velden[i][0] - 1
    zwarte_velden[i][1] = zwarte_velden[i][1] - 1
    
for i in range(len(antwoord)):
    antwoord[i][0] = antwoord[i][0] - 1
    antwoord[i][1] = antwoord[i][1] - 1

# Maak de screen object en pen object via turtle en zet het beginpunt van de screen neer.
screen = turtle.Screen()
screen.setworldcoordinates(-1, -1, screen.window_width() - 1, screen.window_height() - 1)
pen = turtle.Turtle()
  
# het tekenen van een vierkantje
def draw():
  for i in range(4):
    pen.forward(int(700/hoogte))
    pen.left(90)
  pen.forward(int(700/hoogte))

# De code om het bord te laten tekenen
if __name__ == "__main__" :
      
    # Screen setten
    screen.setup(600, 600)
      
    # Snelheid van de 'pen', het turtle object dat gaat tekenen
    pen.speed(1000)
      
    # Loop maken voor het complete bord
    for i in range(breedte):
      
      # Nog niet klaar om te tekenen
      pen.up()
      
      
      # De positie neerzetten voor elke rij
      pen.setpos(0, int(700/hoogte) * i)
      
      # Begin met tekenen
      pen.down()

      for j in range(hoogte):
        # Aanmaken van de kleuren per vakje
        if [j, i] in zwarte_velden:
          color ='black'
        elif [j, i] in antwoord:
          color = '#00dc00'
        else:
          color ='#f0f032'
        # Vul het vakje met de gegeven kleur
        pen.fillcolor(color)
        # Begin het vullen
        pen.begin_fill()
        draw()
        pen.end_fill()
    # Laat de pen verdwijnen als het tekenen klaar is
    pen.hideturtle()
    screen.exitonclick()
